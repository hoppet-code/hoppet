

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>hoppet &mdash; HOPPET 2.2.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=9edc463e" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=16656018"></script>
      <script src="../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            HOPPET
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api.html">Python API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_generated/hoppet_constants.html">HOPPET constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../_generated/github_links.html">Manual in PDF format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">HOPPET</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">hoppet</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for hoppet</h1><div class="highlight"><pre>
<span></span><span class="c1"># This file was automatically generated by SWIG (https://www.swig.org).</span>
<span class="c1"># Version 4.4.1</span>
<span class="c1">#</span>
<span class="c1"># Do not make changes to this file unless you know what you are doing - modify</span>
<span class="c1"># the SWIG interface file instead.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">A Higher Order Perturbative Parton Evolution Toolkit</span>

<span class="sd">HOPPET is a Fortran package for carrying out DGLAP evolution and other </span>
<span class="sd">common manipulations of parton distribution functions (PDFs).</span>

<span class="sd">Citation:</span>
<span class="sd">G.P. Salam, J. Rojo, &#39;A Higher Order Perturbative Parton Evolution Toolkit (HOPPET)&#39;, </span>
<span class="sd">Comput. Phys. Commun. 180 (2009) 120-156, `arXiv:0804.3755 &lt;https://arXiv.org/abs/0804.3755&gt;`_</span>

<span class="sd">and                                                       </span>

<span class="sd">A. Karlberg, P. Nason, G.P. Salam, G. Zanderighi &amp; F. Dreyer, </span>
<span class="sd">`arXiv:2510.09310 &lt;https://arXiv.org/abs/2510.09310&gt;`_. </span>

<span class="sd">Example:</span>
<span class="sd">--------</span>

<span class="sd">   &gt;&gt;&gt; import hoppet as hp</span>
<span class="sd">   &gt;&gt;&gt; import numpy as np</span>
<span class="sd">   &gt;&gt;&gt; </span>
<span class="sd">   &gt;&gt;&gt; def main():</span>
<span class="sd">   &gt;&gt;&gt;     dy = 0.1    </span>
<span class="sd">   &gt;&gt;&gt;     nloop = 3</span>
<span class="sd">   &gt;&gt;&gt;     # Start hoppet</span>
<span class="sd">   &gt;&gt;&gt;     hp.Start(dy, nloop)</span>
<span class="sd">   &gt;&gt;&gt;     </span>
<span class="sd">   &gt;&gt;&gt;     asQ0 = 0.35</span>
<span class="sd">   &gt;&gt;&gt;     Q0 = np.sqrt(2.0)</span>
<span class="sd">   &gt;&gt;&gt;     # Do the evolution. </span>
<span class="sd">   &gt;&gt;&gt;     hp.Evolve(asQ0, Q0, nloop, 1.0, hp.BenchmarkPDFunpol, Q0)</span>
<span class="sd">   &gt;&gt;&gt; </span>
<span class="sd">   &gt;&gt;&gt;     # Evaluate the PDFs at some x values and print them</span>
<span class="sd">   &gt;&gt;&gt;     xvals = [1e-5,1e-4,1e-3,1e-2,0.1,0.3,0.5,0.7,0.9]</span>
<span class="sd">   &gt;&gt;&gt;     Q = 100.0</span>
<span class="sd">   &gt;&gt;&gt; </span>
<span class="sd">   &gt;&gt;&gt;     print(&#39;&#39;)</span>
<span class="sd">   &gt;&gt;&gt;     print(&#39;           Evaluating PDFs at Q =&#39;,Q, &#39; GeV&#39;)</span>
<span class="sd">   &gt;&gt;&gt;     print(&#39;    x      u-ubar      d-dbar    2(ubr+dbr)    c+cbar       gluon&#39;)</span>
<span class="sd">   &gt;&gt;&gt;     for ix in range(9):</span>
<span class="sd">   &gt;&gt;&gt;         pdf_array = hp.Eval(xvals[ix], Q)</span>
<span class="sd">   &gt;&gt;&gt;         print(&#39;{:7.1E} {:11.4E} {:11.4E} {:11.4E} {:11.4E} {:11.4E}&#39;.format(</span>
<span class="sd">   &gt;&gt;&gt;             xvals[ix],</span>
<span class="sd">   &gt;&gt;&gt;             pdf_array[6 + 2] - pdf_array[6 - 2], </span>
<span class="sd">   &gt;&gt;&gt;             pdf_array[6 + 1] - pdf_array[6 - 1], </span>
<span class="sd">   &gt;&gt;&gt;             2 * (pdf_array[6 - 1] + pdf_array[6 - 2]),</span>
<span class="sd">   &gt;&gt;&gt;             pdf_array[6 - 4] + pdf_array[6 + 4],</span>
<span class="sd">   &gt;&gt;&gt;             pdf_array[6 + 0]</span>
<span class="sd">   &gt;&gt;&gt;         ))</span>
<span class="sd">   &gt;&gt;&gt; </span>
<span class="sd">   &gt;&gt;&gt;     hp.DeleteAll()</span>
<span class="sd">   </span>
<span class="sd">For more examples, see https://github.com/hoppet-code/hoppet/tree/master/example_py	</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">version_info</span> <span class="k">as</span> <span class="n">_swig_python_version_info</span>
<span class="c1"># Import the low-level C/C++ module</span>
<span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">globals</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;__spec__&quot;</span><span class="p">),</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">__package__</span> <span class="ow">or</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="vm">__name__</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_hoppet_swig</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">_hoppet_swig</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">builtins</span> <span class="k">as</span> <span class="nn">__builtin__</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">__builtin__</span>

<span class="k">def</span> <span class="nf">_swig_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">strthis</span> <span class="o">=</span> <span class="s2">&quot;proxy of &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
        <span class="n">strthis</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">; </span><span class="si">%s</span><span class="s2"> &gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">strthis</span><span class="p">,)</span>


<span class="k">def</span> <span class="nf">_swig_setattr_nondynamic_instance_variable</span><span class="p">(</span><span class="nb">set</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">set_instance_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;this&quot;</span><span class="p">:</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;thisown&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">name</span><span class="p">),</span> <span class="nb">property</span><span class="p">):</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;You cannot add instance attributes to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">set_instance_attr</span>


<span class="k">def</span> <span class="nf">_swig_setattr_nondynamic_class_variable</span><span class="p">(</span><span class="nb">set</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">set_class_attr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="nb">property</span><span class="p">):</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;You cannot add class attributes to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">set_class_attr</span>


<span class="k">def</span> <span class="nf">_swig_add_metaclass</span><span class="p">(</span><span class="n">metaclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">metaclass</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">class</span> <span class="nc">_SwigNonDynamicMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Meta class to enforce nondynamic attributes (no new attributes) for a class&quot;&quot;&quot;</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="n">_swig_setattr_nondynamic_class_variable</span><span class="p">(</span><span class="nb">type</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">)</span>



<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;2.2.1&quot;</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Frederic Dreyer, Alexander Karlberg, Paolo Nason, Juan Rojo, Gavin Salam, Giulia Zanderighi&quot;</span>


<div class="viewcode-block" id="SetFFN">
<a class="viewcode-back" href="../api.html#hoppet.SetFFN">[docs]</a>
<span class="k">def</span> <span class="nf">SetFFN</span><span class="p">(</span><span class="n">fixed_nf</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set things up to be a fixed-flavour number scheme with the given</span>
<span class="sd">    fixed_nf number of flavours</span>

<span class="sd">    :type fixed_nf: int</span>
<span class="sd">    :param fixed_nf: Value of fixed number of flavours (e.g. 5)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">SetFFN</span><span class="p">(</span><span class="n">fixed_nf</span><span class="p">)</span></div>


<div class="viewcode-block" id="SetVFN">
<a class="viewcode-back" href="../api.html#hoppet.SetVFN">[docs]</a>
<span class="k">def</span> <span class="nf">SetVFN</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">mt</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set things up to be a variable-flavour number scheme with the</span>
<span class="sd">    given quark (pole) masses. Now deprecated; use</span>
<span class="sd">    hoppetSetPoleMassVFN instead, which is what is being called</span>
<span class="sd">    undder the hood.</span>

<span class="sd">    :type mc: float</span>
<span class="sd">    :param mc: Charm mass</span>
<span class="sd">    :type mb: float</span>
<span class="sd">    :param mb: Bottom mass</span>
<span class="sd">    :type mt: float</span>
<span class="sd">    :param mt: Top mass</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">SetVFN</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span></div>


<div class="viewcode-block" id="SetPoleMassVFN">
<a class="viewcode-back" href="../api.html#hoppet.SetPoleMassVFN">[docs]</a>
<span class="k">def</span> <span class="nf">SetPoleMassVFN</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">mt</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set things up to be a variable-flavour number scheme with the</span>
<span class="sd">    given quark (pole) masses. Thresholds are crossed at the pole</span>
<span class="sd">    masses, both for the coupling and the PDF evolution.</span>

<span class="sd">    :type mc: float</span>
<span class="sd">    :param mc: Charm mass</span>
<span class="sd">    :type mb: float</span>
<span class="sd">    :param mb: Bottom mass</span>
<span class="sd">    :type mt: float</span>
<span class="sd">    :param mt: Top mass</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">SetPoleMassVFN</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span></div>


<div class="viewcode-block" id="SetMSbarMassVFN">
<a class="viewcode-back" href="../api.html#hoppet.SetMSbarMassVFN">[docs]</a>
<span class="k">def</span> <span class="nf">SetMSbarMassVFN</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">mt</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set things up to be a variable-flavour number scheme with the given</span>
<span class="sd">    quark (MSbar) masses. Thresholds are crossed at the MSbar</span>
<span class="sd">    masses, both for the coupling and the PDF evolution.</span>

<span class="sd">    :type mc: float</span>
<span class="sd">    :param mc: Charm mass</span>
<span class="sd">    :type mb: float</span>
<span class="sd">    :param mb: Bottom mass</span>
<span class="sd">    :type mt: float</span>
<span class="sd">    :param mt: Top mass</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">SetMSbarMassVFN</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">mt</span><span class="p">)</span></div>


<div class="viewcode-block" id="SetExactDGLAP">
<a class="viewcode-back" href="../api.html#hoppet.SetExactDGLAP">[docs]</a>
<span class="k">def</span> <span class="nf">SetExactDGLAP</span><span class="p">(</span><span class="n">exact_nfthreshold</span><span class="p">,</span> <span class="n">exact_splitting</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arrange for the use of exact NNLO splitting and mass-threshold</span>
<span class="sd">    functions.</span>

<span class="sd">    :type exact_nfthreshold: boolean</span>
<span class="sd">    :param exact_nfthreshold: If True use the exact NNLO mass</span>
<span class="sd">        threshold functions. If False use the faster parametrisations</span>
<span class="sd">    :type exact_splitting: boolean</span>
<span class="sd">    :param exact_splitting: If True use the exact NNLO splitting</span>
<span class="sd">        functions. If False use the faster parametrisations</span>

<span class="sd">    To be called before hoppetStart</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">SetExactDGLAP</span><span class="p">(</span><span class="n">exact_nfthreshold</span><span class="p">,</span> <span class="n">exact_splitting</span><span class="p">)</span></div>


<div class="viewcode-block" id="SetApproximateDGLAPN3LO">
<a class="viewcode-back" href="../api.html#hoppet.SetApproximateDGLAPN3LO">[docs]</a>
<span class="k">def</span> <span class="nf">SetApproximateDGLAPN3LO</span><span class="p">(</span><span class="n">splitting_variant</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arrange for the use of various approximate N3LO splitting functions.</span>

<span class="sd">    :type splitting_variant: int</span>
<span class="sd">    :param splitting_variant: One of the hoppet.n3lo_splitting_approximation_* options.</span>

<span class="sd">    To be called before hoppetStart</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">SetApproximateDGLAPN3LO</span><span class="p">(</span><span class="n">splitting_variant</span><span class="p">)</span></div>


<div class="viewcode-block" id="SetSplittingNNLO">
<a class="viewcode-back" href="../api.html#hoppet.SetSplittingNNLO">[docs]</a>
<span class="k">def</span> <span class="nf">SetSplittingNNLO</span><span class="p">(</span><span class="n">splitting_variant</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arrange for the use of various NNLO splitting functions.</span>

<span class="sd">    :type splitting_variant: int</span>
<span class="sd">    :param splitting_variant: One of the hoppet.nnlo_splitting_* options.</span>

<span class="sd">    To be called before hoppetStart</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">SetSplittingNNLO</span><span class="p">(</span><span class="n">splitting_variant</span><span class="p">)</span></div>


<div class="viewcode-block" id="SetSplittingN3LO">
<a class="viewcode-back" href="../api.html#hoppet.SetSplittingN3LO">[docs]</a>
<span class="k">def</span> <span class="nf">SetSplittingN3LO</span><span class="p">(</span><span class="n">splitting_variant</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change the variant for the N3LO splitting functions.</span>

<span class="sd">    :type splitting_variant: int</span>
<span class="sd">    :param splitting_variant: One of the hoppet.n3lo_splitting_* options.</span>

<span class="sd">    To be called before hoppetStart</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">SetSplittingN3LO</span><span class="p">(</span><span class="n">splitting_variant</span><span class="p">)</span></div>


<div class="viewcode-block" id="SetN3LOnfthresholds">
<a class="viewcode-back" href="../api.html#hoppet.SetN3LOnfthresholds">[docs]</a>
<span class="k">def</span> <span class="nf">SetN3LOnfthresholds</span><span class="p">(</span><span class="n">variant</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     Arrange for the use of N3LO mass thresholds or not.</span>

<span class="sd">    :type variant: int</span>
<span class="sd">    :param variant: One of the hoppet.n3lo_nfthresholds_* options.</span>

<span class="sd">    To be called before hoppetStart</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">SetN3LOnfthresholds</span><span class="p">(</span><span class="n">variant</span><span class="p">)</span></div>


<div class="viewcode-block" id="SetYLnlnQInterpOrders">
<a class="viewcode-back" href="../api.html#hoppet.SetYLnlnQInterpOrders">[docs]</a>
<span class="k">def</span> <span class="nf">SetYLnlnQInterpOrders</span><span class="p">(</span><span class="n">yorder</span><span class="p">,</span> <span class="n">lnlnQorder</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     Override the default interpolation order in y and lnlnQ.</span>

<span class="sd">    :type yorder: int</span>
<span class="sd">    :param yorder: The interpolation order in y (default: 5)</span>
<span class="sd">    :type lnlnQorder: int</span>
<span class="sd">    :param lnlnQorder: The interpolation order in lnlnQ (default: 4)</span>

<span class="sd">    2 corresponds to quadratic, 3 to cubic etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">SetYLnlnQInterpOrders</span><span class="p">(</span><span class="n">yorder</span><span class="p">,</span> <span class="n">lnlnQorder</span><span class="p">)</span></div>


<div class="viewcode-block" id="SetCoupling">
<a class="viewcode-back" href="../api.html#hoppet.SetCoupling">[docs]</a>
<span class="k">def</span> <span class="nf">SetCoupling</span><span class="p">(</span><span class="n">asQ0</span><span class="p">,</span> <span class="n">Q0alphas</span><span class="p">,</span> <span class="n">nloop</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set up the strong coupling such that alphas(Q)=alphas_Q, with the</span>
<span class="sd">    given number of loops (nloop).</span>

<span class="sd">    The user should have set the quark masses or requested a FFN scheme</span>
<span class="sd">    prior to calling this function.</span>

<span class="sd">    This function is provided mainly for use in conjunction with</span>
<span class="sd">    hoppetAssign (C++) :func:`Assign` (Python).  In particular, it</span>
<span class="sd">    has the side effect of modifying the structure of the PDF tables</span>
<span class="sd">    to make sure they know about the mass thresholds.</span>

<span class="sd">    If QED has been requested, a QED coupling will also be set up</span>
<span class="sd">    (its value is not currently configurable from this interface).</span>

<span class="sd">    If you call hoppetEvolve (C++) :func:`Evolve` (Python), there is</span>
<span class="sd">    no need to separately call this routine.</span>

<span class="sd">    :type asQ0: float</span>
<span class="sd">    :param asQ0: alphas at the scale Q0</span>
<span class="sd">    :type Q0alphas: float</span>
<span class="sd">    :param Q0alphas: the scale Q0</span>
<span class="sd">    :type nloop: int</span>
<span class="sd">    :param nloop: Perturbative order (1: LO, 2: NLO, 3: NNLO, 4: N3LO)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">SetCoupling</span><span class="p">(</span><span class="n">asQ0</span><span class="p">,</span> <span class="n">Q0alphas</span><span class="p">,</span> <span class="n">nloop</span><span class="p">)</span></div>


<div class="viewcode-block" id="PreEvolve">
<a class="viewcode-back" href="../api.html#hoppet.PreEvolve">[docs]</a>
<span class="k">def</span> <span class="nf">PreEvolve</span><span class="p">(</span><span class="n">asQ0</span><span class="p">,</span> <span class="n">Q0alphas</span><span class="p">,</span> <span class="n">nloop</span><span class="p">,</span> <span class="n">muR_Q</span><span class="p">,</span> <span class="n">Q0pdf</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepare a cached evolution.  Once this has been called, one can</span>
<span class="sd">    use hoppetCachedEvolve (C++) or :func:`CachedEvolve` (Python) to</span>
<span class="sd">    carry out the cached evolution of a specific initial condition.</span>

<span class="sd">    :type asQ0: float</span>
<span class="sd">    :param asQ0:     Strong coupling at initial scale Q0alphas</span>
<span class="sd">    :type Q0alphas: float</span>
<span class="sd">    :param Q0alphas: Initial scale for alpha_s [GeV]</span>
<span class="sd">    :type nloop: int</span>
<span class="sd">    :param nloop:    Number of loops for evolution (1=LO, 2=NLO, 3=NNLO, 4=N3LO)</span>
<span class="sd">    :type muR_Q: float</span>
<span class="sd">    :param muR_Q:    Ratio of renormalisation scheme to factorisation scale during evolution</span>
<span class="sd">    :type Q0pdf: float</span>
<span class="sd">    :param Q0pdf:    Initial scale for PDF [GeV]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">PreEvolve</span><span class="p">(</span><span class="n">asQ0</span><span class="p">,</span> <span class="n">Q0alphas</span><span class="p">,</span> <span class="n">nloop</span><span class="p">,</span> <span class="n">muR_Q</span><span class="p">,</span> <span class="n">Q0pdf</span><span class="p">)</span></div>


<div class="viewcode-block" id="AlphaS">
<a class="viewcode-back" href="../api.html#hoppet.AlphaS">[docs]</a>
<span class="k">def</span> <span class="nf">AlphaS</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the strong coupling at scale Q</span>

<span class="sd">    :type Q: float</span>
<span class="sd">    :param Q: Scale in GeV</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    :return: The strong coupling</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">AlphaS</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span></div>


<div class="viewcode-block" id="AlphaQED">
<a class="viewcode-back" href="../api.html#hoppet.AlphaQED">[docs]</a>
<span class="k">def</span> <span class="nf">AlphaQED</span><span class="p">(</span><span class="n">Q</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the QED coupling at scale Q</span>

<span class="sd">    :type Q: float</span>
<span class="sd">    :param Q: Scale in GeV</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    :return: The QED coupling</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">AlphaQED</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span></div>


<div class="viewcode-block" id="EvalIFlv">
<a class="viewcode-back" href="../api.html#hoppet.EvalIFlv">[docs]</a>
<span class="k">def</span> <span class="nf">EvalIFlv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">iflv</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return xf(x,Q) for the flavour indicated by iflv, which should</span>
<span class="sd">    be one of the hoppet iflv_* constants (iflv_g, iflv_d,</span>
<span class="sd">    iflv_ubar, etc.)</span>

<span class="sd">    :type x: float</span>
<span class="sd">    :param x: Longitudinal momentum fraction (0 &lt; x &lt; 1)</span>
<span class="sd">    :type Q: float</span>
<span class="sd">    :param Q: Scale in GeV</span>
<span class="sd">    :type iflv: int</span>
<span class="sd">    :param iflv: One of the hoppet.iflv_g, hoppet.iflv_d, etc.</span>

<span class="sd">    :rtype: float</span>
<span class="sd">    :return: xf(x,Q) for the flavour indicated by iflv</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">EvalIFlv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">iflv</span><span class="p">)</span></div>


<div class="viewcode-block" id="StartStrFct">
<a class="viewcode-back" href="../api.html#hoppet.StartStrFct">[docs]</a>
<span class="k">def</span> <span class="nf">StartStrFct</span><span class="p">(</span><span class="n">order_max</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Minimal setup of structure functions</span>

<span class="sd">    :type order_max: int</span>
<span class="sd">    :param order_max: highest order in QCD to compute (1: LO, 2: NLO, 3: NNLO, 4: N3LO)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">StartStrFct</span><span class="p">(</span><span class="n">order_max</span><span class="p">)</span></div>


<div class="viewcode-block" id="StartStrFctExtended">
<a class="viewcode-back" href="../api.html#hoppet.StartStrFctExtended">[docs]</a>
<span class="k">def</span> <span class="nf">StartStrFctExtended</span><span class="p">(</span><span class="n">order_max</span><span class="p">,</span> <span class="n">nflav</span><span class="p">,</span> <span class="n">scale_choice</span><span class="p">,</span> <span class="n">constant_mu</span><span class="p">,</span> <span class="n">param_coefs</span><span class="p">,</span> <span class="n">wmass</span><span class="p">,</span> <span class="n">zmass</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Setup of constants and parameters needed for structure functions</span>

<span class="sd">    :type order_max: int</span>
<span class="sd">    :param order_max:      highest order in QCD to compute (1: LO, 2: NLO, 3: NNLO, 4: N3LO)</span>
<span class="sd">    :type nflav: int</span>
<span class="sd">    :param nflav:          integer number of flavours (if negative use variable flavour)</span>
<span class="sd">    :type scale_choice: int</span>
<span class="sd">    :param scale_choice:   (0: fixed scale, 1: use Q, 2: use arbitrary scale)</span>
<span class="sd">    :type constant_mu: float</span>
<span class="sd">    :param constant_mu:    if scale_choice = scale_choice_fixed (= 0) then this is the fixed scale</span>
<span class="sd">    :type param_coefs: boolean</span>
<span class="sd">    :param param_coefs:    if .true. use parametrised coefficients functions</span>
<span class="sd">    :type wmass: float</span>
<span class="sd">    :param wmass:          Mass of the W boson</span>
<span class="sd">    :type zmass: float</span>
<span class="sd">    :param zmass:          Mass of the z boson</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">StartStrFctExtended</span><span class="p">(</span><span class="n">order_max</span><span class="p">,</span> <span class="n">nflav</span><span class="p">,</span> <span class="n">scale_choice</span><span class="p">,</span> <span class="n">constant_mu</span><span class="p">,</span> <span class="n">param_coefs</span><span class="p">,</span> <span class="n">wmass</span><span class="p">,</span> <span class="n">zmass</span><span class="p">)</span></div>


<div class="viewcode-block" id="hoppetwritelhapdfwithlen_c">
<a class="viewcode-back" href="../api.html#hoppet.hoppetwritelhapdfwithlen_c">[docs]</a>
<span class="k">def</span> <span class="nf">hoppetwritelhapdfwithlen_c</span><span class="p">(</span><span class="n">basename_len</span><span class="p">,</span> <span class="n">basename</span><span class="p">,</span> <span class="n">pdf_index</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">hoppetwritelhapdfwithlen_c</span><span class="p">(</span><span class="n">basename_len</span><span class="p">,</span> <span class="n">basename</span><span class="p">,</span> <span class="n">pdf_index</span><span class="p">)</span></div>


<div class="viewcode-block" id="WriteLHAPDFGrid">
<a class="viewcode-back" href="../api.html#hoppet.WriteLHAPDFGrid">[docs]</a>
<span class="k">def</span> <span class="nf">WriteLHAPDFGrid</span><span class="p">(</span><span class="n">basename</span><span class="p">,</span> <span class="n">pdf_index</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write out the contents of tables(0) (assumed to be the PDF) in the</span>
<span class="sd">    LHAPDF format</span>

<span class="sd">    :type basename: string</span>
<span class="sd">    :param basename: The basename of the output</span>
<span class="sd">    :type pdf_index: int</span>
<span class="sd">    :param pdf_index: The intended index in the LHAPDF meaning. If index is 0 both the PDF and the .info file is saved to disk</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">WriteLHAPDFGrid</span><span class="p">(</span><span class="n">basename</span><span class="p">,</span> <span class="n">pdf_index</span><span class="p">)</span></div>


<div class="viewcode-block" id="SetQED">
<a class="viewcode-back" href="../api.html#hoppet.SetQED">[docs]</a>
<span class="k">def</span> <span class="nf">SetQED</span><span class="p">(</span><span class="n">withqed</span><span class="p">,</span> <span class="n">qcdqed</span><span class="p">,</span> <span class="n">plq</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Enable or disable QED evolution with photon and lepton PDFs.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      withqed (int): 1 to enable QED evolution, 0 to disable</span>
<span class="sd">      qcdqed (int): Treatment of QCD-QED coupling (implementation-specific)</span>
<span class="sd">      plq (int): 1 to enable lepton splitting function</span>

<span class="sd">      Note: Must be called before :func:`Start` as it modifies global PDF settings.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">SetQED</span><span class="p">(</span><span class="n">withqed</span><span class="p">,</span> <span class="n">qcdqed</span><span class="p">,</span> <span class="n">plq</span><span class="p">)</span></div>


<div class="viewcode-block" id="Start">
<a class="viewcode-back" href="../api.html#hoppet.Start">[docs]</a>
<span class="k">def</span> <span class="nf">Start</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">nloop</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Initialize HOPPET evolution tables with basic parameters.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      dy (float): Step size in ln(1/x). Typical range: 0.05-0.2</span>
<span class="sd">      nloop (int): Maximum number of loops (1=LO, 2=NLO, 3=NNLO, 4=N3LO)</span>

<span class="sd">      Note: This is the basic initialization. For more control, use</span>
<span class="sd">      :func:`StartExtended`.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">Start</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">nloop</span><span class="p">)</span></div>


<div class="viewcode-block" id="StartExtended">
<a class="viewcode-back" href="../api.html#hoppet.StartExtended">[docs]</a>
<span class="k">def</span> <span class="nf">StartExtended</span><span class="p">(</span><span class="n">ymax</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">Qmin</span><span class="p">,</span> <span class="n">Qmax</span><span class="p">,</span> <span class="n">dlnlnQ</span><span class="p">,</span> <span class="n">nloop</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">factscheme</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Initialize HOPPET evolution tables with extended parameters.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      ymax (float): Highest value of ln(1/x) user wants to access</span>
<span class="sd">      dy (float): Internal ln(1/x) grid spacing (0.05-0.2 is sensible)</span>
<span class="sd">      Qmin (float): Lower limit of Q range [GeV]</span>
<span class="sd">      Qmax (float): Upper limit of Q range [GeV]  </span>
<span class="sd">      dlnlnQ (float): Internal table spacing in ln(ln(Q)) (e.g. dy/4)</span>
<span class="sd">      nloop (int): Maximum number of loops (1=LO, 2=NLO, 3=NNLO, 4=N3LO)</span>
<span class="sd">      order (int): Order of numerical interpolation (e.g. -6)</span>
<span class="sd">       factscheme (int): One of the hoppet.factscheme_* factorization scheme identifier (e.g. hoppet.factscheme_MSbar)</span>

<span class="sd">    This provides full control over the evolution grid setup.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">StartExtended</span><span class="p">(</span><span class="n">ymax</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">Qmin</span><span class="p">,</span> <span class="n">Qmax</span><span class="p">,</span> <span class="n">dlnlnQ</span><span class="p">,</span> <span class="n">nloop</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">factscheme</span><span class="p">)</span></div>


<div class="viewcode-block" id="InitStrFct">
<a class="viewcode-back" href="../api.html#hoppet.InitStrFct">[docs]</a>
<span class="k">def</span> <span class="nf">InitStrFct</span><span class="p">(</span><span class="n">order_max</span><span class="p">,</span> <span class="n">separate_orders</span><span class="p">,</span> <span class="n">xR</span><span class="p">,</span> <span class="n">xF</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Initialize structure function calculations.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      order_max (int): Maximum perturbative order &lt;=4</span>
<span class="sd">      separate_orders (int): Whether to separate by order</span>
<span class="sd">      xR (float): Renormalization scale factor</span>
<span class="sd">      xF (float): Factorization scale factor</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">InitStrFct</span><span class="p">(</span><span class="n">order_max</span><span class="p">,</span> <span class="n">separate_orders</span><span class="p">,</span> <span class="n">xR</span><span class="p">,</span> <span class="n">xF</span><span class="p">)</span></div>


<div class="viewcode-block" id="InitStrFctFlav">
<a class="viewcode-back" href="../api.html#hoppet.InitStrFctFlav">[docs]</a>
<span class="k">def</span> <span class="nf">InitStrFctFlav</span><span class="p">(</span><span class="n">order_max</span><span class="p">,</span> <span class="n">separate_orders</span><span class="p">,</span> <span class="n">xR</span><span class="p">,</span> <span class="n">xF</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Initialize flavour-decomposed structure function calculations.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      order_max (int): Maximum perturbative order &lt;=4</span>
<span class="sd">      separate_orders (int): Whether to separate by order  </span>
<span class="sd">      xR (float): Renormalization scale factor</span>
<span class="sd">      xF (float): Factorization scale factor</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">InitStrFctFlav</span><span class="p">(</span><span class="n">order_max</span><span class="p">,</span> <span class="n">separate_orders</span><span class="p">,</span> <span class="n">xR</span><span class="p">,</span> <span class="n">xF</span><span class="p">)</span></div>


<div class="viewcode-block" id="DeleteAll">
<a class="viewcode-back" href="../api.html#hoppet.DeleteAll">[docs]</a>
<span class="k">def</span> <span class="nf">DeleteAll</span><span class="p">():</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Clean up and free all HOPPET internal arrays and memory.</span>

<span class="sd">    Call this at the end of your program to free resources.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">DeleteAll</span><span class="p">()</span></div>


<div class="viewcode-block" id="Assign">
<a class="viewcode-back" href="../api.html#hoppet.Assign">[docs]</a>
<span class="k">def</span> <span class="nf">Assign</span><span class="p">(</span><span class="n">callback</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Assign a PDF function to HOPPET without evolution.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      callback (callable): Python function with signature callback(x, Q) </span>
<span class="sd">                           returning array of 13 PDF values</span>

<span class="sd">    The callback should return PDFs in HOPPET order:</span>

<span class="sd">    [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t]</span>

<span class="sd">    or if QED evolution is included</span>

<span class="sd">    [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t, EMPTY, photon, electron, muon, tau]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">Assign</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span></div>


<div class="viewcode-block" id="Evolve">
<a class="viewcode-back" href="../api.html#hoppet.Evolve">[docs]</a>
<span class="k">def</span> <span class="nf">Evolve</span><span class="p">(</span><span class="n">asQ0</span><span class="p">,</span> <span class="n">Q0alphas</span><span class="p">,</span> <span class="n">nloop</span><span class="p">,</span> <span class="n">muR_Q</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">Q0pdf</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Evolve PDFs from initial scale Q0 to all scales in the grid.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      asQ0 (float): Strong coupling at initial scale</span>
<span class="sd">      Q0alphas (float): Reference scale for alpha_s [GeV]</span>
<span class="sd">      nloop (int): Number of loops for evolution</span>
<span class="sd">      muR_Q (float): Renormalization scale ratio (muR/Q)</span>
<span class="sd">      callback (callable): PDF function with signature callback(x, Q)</span>
<span class="sd">      Q0pdf (float): Initial scale for PDF [GeV]</span>

<span class="sd">    The callback should return PDFs in HOPPET order:</span>

<span class="sd">    [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t]</span>

<span class="sd">    or if QED evolution is included</span>

<span class="sd">    [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t, EMPTY, photon, electron, muon, tau]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">Evolve</span><span class="p">(</span><span class="n">asQ0</span><span class="p">,</span> <span class="n">Q0alphas</span><span class="p">,</span> <span class="n">nloop</span><span class="p">,</span> <span class="n">muR_Q</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">Q0pdf</span><span class="p">)</span></div>


<div class="viewcode-block" id="CachedEvolve">
<a class="viewcode-back" href="../api.html#hoppet.CachedEvolve">[docs]</a>
<span class="k">def</span> <span class="nf">CachedEvolve</span><span class="p">(</span><span class="n">callback</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Perform a cached evolution.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      callback (callable): PDF function with signature callback(x, Q)</span>
<span class="sd">                           returning array of 13/18 PDF values</span>

<span class="sd">    More efficient than :func:`Evolve` when doing multiple evolutions. Needs a call to :func:`PreEvolve` first.</span>

<span class="sd">    The callback should return PDFs in HOPPET order:</span>

<span class="sd">    [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t]</span>

<span class="sd">    or if QED evolution is included</span>

<span class="sd">    [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t, EMPTY, photon, electron, muon, tau]</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">CachedEvolve</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span></div>


<div class="viewcode-block" id="Eval">
<a class="viewcode-back" href="../api.html#hoppet.Eval">[docs]</a>
<span class="k">def</span> <span class="nf">Eval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Evaluate evolved PDFs at given x and Q.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      x (float): Longitudinal momentum fraction (0 &lt; x &lt; 1)</span>
<span class="sd">      Q (float): Momentum scale [GeV]</span>

<span class="sd">    Returns:</span>
<span class="sd">      list: Array of 13/18 PDF values in HOPPET order:</span>
<span class="sd">      [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t]</span>
<span class="sd">      or if QED evolution is included</span>
<span class="sd">      [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t, EMPTY, photon, electron, muon, tau]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">Eval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span></div>


<div class="viewcode-block" id="EvalSplit">
<a class="viewcode-back" href="../api.html#hoppet.EvalSplit">[docs]</a>
<span class="k">def</span> <span class="nf">EvalSplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">iloop</span><span class="p">,</span> <span class="n">nf</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">     Return the value of </span>

<span class="sd">        [P(iloop,nf) \otimes pdf] (x,Q)</span>

<span class="sd">     where P(iloop,nf) is the iloop-splitting function for the given</span>
<span class="sd">     value of nf, and pdf is our internally stored pdf.</span>

<span class="sd">     The normalisation is such that the nloop dglap evolution equation is</span>

<span class="sd">         dpdf/dlnQ^2 = sum_{iloop=1}^nloop </span>
<span class="sd">                            (alphas/(2*pi))^iloop * P(iloop,nf) \otimes pdf</span>

<span class="sd">     Note that each time nf changes relative to a previous call for the</span>
<span class="sd">     same iloop, the convolution has to be repeated for the whole</span>
<span class="sd">     table. So for efficient results when requiring multiple nf values,</span>
<span class="sd">     calls with the same nf value should be grouped together.</span>

<span class="sd">     In particular, for repeated calls with the same value of nf, the</span>
<span class="sd">     convolutions are carried out only on the first call (i.e. once for</span>
<span class="sd">     each value of iloop). Multiple calls with different values for</span>
<span class="sd">     iloop can be carried out without problems.</span>

<span class="sd">     Note that iloop can also be of the form ij or ijk, which means</span>
<span class="sd">     P(i)*P(j)*pdf or P(i)*P(j)*P(k)*pdf. The sum of i+j+k is currently</span>
<span class="sd">     bounded to be &lt;= 4.</span>

<span class="sd">     The number of loops must be consistent with iloop</span>

<span class="sd">    Parameters:</span>
<span class="sd">      x (float): Longitudinal momentum fraction (0 &lt; x &lt; 1)</span>
<span class="sd">      Q (float): Momentum scale [GeV]</span>
<span class="sd">      iloop (int): Perturbative order (1=LO, 2=NLO, etc.)</span>
<span class="sd">      nf (int): Number of active flavours</span>

<span class="sd">    Returns:</span>
<span class="sd">      list: Array of 13/18 PDF values in HOPPET order:</span>
<span class="sd">      [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t]</span>
<span class="sd">      or if QED evolution is included</span>
<span class="sd">      [tbar, bbar, cbar, sbar, ubar, dbar, g, d, u, s, c, b, t, EMPTY, photon, electron, muon, tau]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">EvalSplit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">iloop</span><span class="p">,</span> <span class="n">nf</span><span class="p">)</span></div>


<div class="viewcode-block" id="BenchmarkPDFunpol">
<a class="viewcode-back" href="../api.html#hoppet.BenchmarkPDFunpol">[docs]</a>
<span class="k">def</span> <span class="nf">BenchmarkPDFunpol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Evaluate the unpolarized benchmark PDF set.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      x (float): Longitudinal momentum fraction (0 &lt; x &lt; 1)  </span>
<span class="sd">      Q (float): Momentum scale [GeV]</span>

<span class="sd">    Returns:</span>
<span class="sd">      list: Array of 13 benchmark PDF values</span>

<span class="sd">    Useful for testing and validation against known results. For a</span>
<span class="sd">    benchmark PDF with photon and leptons look at</span>
<span class="sd">    `example_py/tabulation_example_qed.py</span>
<span class="sd">    &lt;https://github.com/hoppet-code/hoppet/blob/master/example_py/tabulation_example_qed.py&gt;`_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">BenchmarkPDFunpol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span></div>


<div class="viewcode-block" id="StrFct">
<a class="viewcode-back" href="../api.html#hoppet.StrFct">[docs]</a>
<span class="k">def</span> <span class="nf">StrFct</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Calculate structure functions with specified scales.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      x (float): Longitudinal momentum fraction</span>
<span class="sd">      Q (float): Hard scale [GeV]</span>
<span class="sd">      muR_in (float): Renormalization scale [GeV]</span>
<span class="sd">      muF_in (float): Factorization scale [GeV]</span>

<span class="sd">    Returns:</span>
<span class="sd">      list: Array of structure function values where the indices correspond to the hoppet.iF1Wp etc. constants</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">StrFct</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">)</span></div>


<div class="viewcode-block" id="StrFctNoMu">
<a class="viewcode-back" href="../api.html#hoppet.StrFctNoMu">[docs]</a>
<span class="k">def</span> <span class="nf">StrFctNoMu</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Calculate structure functions with default scale choices.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      x (float): Longitudinal momentum fraction</span>
<span class="sd">      Q (float): Hard scale [GeV] (used for both muR and muF)</span>

<span class="sd">    Returns:</span>
<span class="sd">      list: Array of structure function values where the indices correspond to the hoppet.iF1Wp etc. constants</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">StrFctNoMu</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span></div>


<div class="viewcode-block" id="StrFctLO">
<a class="viewcode-back" href="../api.html#hoppet.StrFctLO">[docs]</a>
<span class="k">def</span> <span class="nf">StrFctLO</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Calculate leading-order structure functions.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      x (float): Longitudinal momentum fraction</span>
<span class="sd">      Q (float): Hard scale [GeV]</span>
<span class="sd">      muR_in (float): Renormalization scale [GeV]</span>
<span class="sd">      muF_in (float): Factorization scale [GeV]</span>

<span class="sd">    Returns:</span>
<span class="sd">      list: Array of LO structure function values where the indices correspond to the hoppet.iF1Wp etc. constants</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">StrFctLO</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">)</span></div>


<div class="viewcode-block" id="StrFctNLO">
<a class="viewcode-back" href="../api.html#hoppet.StrFctNLO">[docs]</a>
<span class="k">def</span> <span class="nf">StrFctNLO</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Calculate next-to-leading-order structure functions.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      x (float): Longitudinal momentum fraction</span>
<span class="sd">      Q (float): Hard scale [GeV]</span>
<span class="sd">      muR_in (float): Renormalization scale [GeV]</span>
<span class="sd">      muF_in (float): Factorization scale [GeV]</span>

<span class="sd">    Returns:</span>
<span class="sd">      list: Array of NLO structure function values where the indices correspond to the hoppet.iF1Wp etc. constants</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">StrFctNLO</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">)</span></div>


<div class="viewcode-block" id="StrFctFlav">
<a class="viewcode-back" href="../api.html#hoppet.StrFctFlav">[docs]</a>
<span class="k">def</span> <span class="nf">StrFctFlav</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">,</span> <span class="n">flav</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Calculate flavour-decomposed structure functions.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      x (float): Longitudinal momentum fraction</span>
<span class="sd">      Q (float): Hard scale [GeV]</span>
<span class="sd">      muR_in (float): Renormalization scale [GeV]</span>
<span class="sd">      muF_in (float): Factorization scale [GeV]</span>
<span class="sd">      flav (int): Flavour index (one of hoppet.iflv* constants)</span>

<span class="sd">    Returns:</span>
<span class="sd">       list: Array of structure function values for specified flavour where indices correspond to FL, F2, F3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">StrFctFlav</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">,</span> <span class="n">flav</span><span class="p">)</span></div>


<div class="viewcode-block" id="StrFctNoMuFlav">
<a class="viewcode-back" href="../api.html#hoppet.StrFctNoMuFlav">[docs]</a>
<span class="k">def</span> <span class="nf">StrFctNoMuFlav</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">flav</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Calculate flavour-decomposed structure functions with default scales.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      x (float): Longitudinal momentum fraction</span>
<span class="sd">      Q (float): Hard scale [GeV]  </span>
<span class="sd">      flav (int): Flavour index</span>

<span class="sd">    Returns:</span>
<span class="sd">      list: Array of structure function values for specified flavour where indices correspond to FL, F2, F3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">StrFctNoMuFlav</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">flav</span><span class="p">)</span></div>


<div class="viewcode-block" id="StrFctLOFlav">
<a class="viewcode-back" href="../api.html#hoppet.StrFctLOFlav">[docs]</a>
<span class="k">def</span> <span class="nf">StrFctLOFlav</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">,</span> <span class="n">flav</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Calculate LO flavour-decomposed structure functions.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      x (float): Longitudinal momentum fraction</span>
<span class="sd">      Q (float): Hard scale [GeV]</span>
<span class="sd">      muR_in (float): Renormalization scale [GeV]</span>
<span class="sd">      muF_in (float): Factorization scale [GeV]</span>
<span class="sd">      flav (int): Flavour index</span>

<span class="sd">    Returns:</span>
<span class="sd">      list: Array of LO structure function values for specified flavour where indices correspond to FL, F2, F3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">StrFctLOFlav</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">,</span> <span class="n">flav</span><span class="p">)</span></div>


<div class="viewcode-block" id="StrFctNLOFlav">
<a class="viewcode-back" href="../api.html#hoppet.StrFctNLOFlav">[docs]</a>
<span class="k">def</span> <span class="nf">StrFctNLOFlav</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">,</span> <span class="n">flav</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Calculate NLO flavour-decomposed structure functions.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      x (float): Longitudinal momentum fraction</span>
<span class="sd">      Q (float): Hard scale [GeV]</span>
<span class="sd">      muR_in (float): Renormalization scale [GeV]</span>
<span class="sd">      muF_in (float): Factorization scale [GeV]</span>
<span class="sd">      flav (int): Flavour index</span>

<span class="sd">    Returns:</span>
<span class="sd">      list: Array of NLO structure function values for specified flavour where indices correspond to FL, F2, F3</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">StrFctNLOFlav</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">,</span> <span class="n">flav</span><span class="p">)</span></div>


<div class="viewcode-block" id="StrFctNNLO">
<a class="viewcode-back" href="../api.html#hoppet.StrFctNNLO">[docs]</a>
<span class="k">def</span> <span class="nf">StrFctNNLO</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Calculate next-to-next-to-leading-order structure functions.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      x (float): Longitudinal momentum fraction</span>
<span class="sd">      Q (float): Hard scale [GeV]</span>
<span class="sd">      muR_in (float): Renormalization scale [GeV]  </span>
<span class="sd">      muF_in (float): Factorization scale [GeV]</span>

<span class="sd">    Returns:</span>
<span class="sd">      list: Array of NNLO structure function values where the indices correspond to the hoppet.iF1Wp etc. constants</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">StrFctNNLO</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">)</span></div>


<div class="viewcode-block" id="StrFctN3LO">
<a class="viewcode-back" href="../api.html#hoppet.StrFctN3LO">[docs]</a>
<span class="k">def</span> <span class="nf">StrFctN3LO</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Calculate next-to-next-to-next-to-leading-order structure functions.</span>

<span class="sd">    Parameters:</span>
<span class="sd">      x (float): Longitudinal momentum fraction</span>
<span class="sd">      Q (float): Hard scale [GeV]</span>
<span class="sd">      muR_in (float): Renormalization scale [GeV]</span>
<span class="sd">      muF_in (float): Factorization scale [GeV]</span>

<span class="sd">    Returns:</span>
<span class="sd">      list: Array of N3LO structure function values where the indices correspond to the hoppet.iF1Wp etc. constants</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">StrFctN3LO</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">muR_in</span><span class="p">,</span> <span class="n">muF_in</span><span class="p">)</span></div>


<span class="n">cvar</span> <span class="o">=</span> <span class="n">_hoppet_swig</span><span class="o">.</span><span class="n">cvar</span>
<span class="n">cc_REAL</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">cc_REAL</span>
<span class="n">cc_VIRT</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">cc_VIRT</span>
<span class="n">cc_REALVIRT</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">cc_REALVIRT</span>
<span class="n">cc_DELTA</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">cc_DELTA</span>
<span class="n">iflv_g</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_g</span>
<span class="n">iflv_d</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_d</span>
<span class="n">iflv_u</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_u</span>
<span class="n">iflv_s</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_s</span>
<span class="n">iflv_c</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_c</span>
<span class="n">iflv_b</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_b</span>
<span class="n">iflv_t</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_t</span>
<span class="n">iflv_dbar</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_dbar</span>
<span class="n">iflv_ubar</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_ubar</span>
<span class="n">iflv_sbar</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_sbar</span>
<span class="n">iflv_cbar</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_cbar</span>
<span class="n">iflv_bbar</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_bbar</span>
<span class="n">iflv_tbar</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_tbar</span>
<span class="n">iflv_photon</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_photon</span>
<span class="n">iflv_electron</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_electron</span>
<span class="n">iflv_muon</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_muon</span>
<span class="n">iflv_tau</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_tau</span>
<span class="n">iflv_min</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_min</span>
<span class="n">iflv_max</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_max</span>
<span class="n">iflv_info</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_info</span>
<span class="n">ncompmin</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">ncompmin</span>
<span class="n">ncompmax</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">ncompmax</span>
<span class="n">iflv_min_fortran</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iflv_min_fortran</span>
<span class="n">iF1Wp</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iF1Wp</span>
<span class="n">iF2Wp</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iF2Wp</span>
<span class="n">iF3Wp</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iF3Wp</span>
<span class="n">iF1Wm</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iF1Wm</span>
<span class="n">iF2Wm</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iF2Wm</span>
<span class="n">iF3Wm</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iF3Wm</span>
<span class="n">iF1Z</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iF1Z</span>
<span class="n">iF2Z</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iF2Z</span>
<span class="n">iF3Z</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iF3Z</span>
<span class="n">iF1EM</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iF1EM</span>
<span class="n">iF2EM</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iF2EM</span>
<span class="n">iF1gZ</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iF1gZ</span>
<span class="n">iF2gZ</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iF2gZ</span>
<span class="n">iF3gZ</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">iF3gZ</span>
<span class="n">scale_choice_fixed</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">scale_choice_fixed</span>
<span class="n">scale_choice_Q</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">scale_choice_Q</span>
<span class="n">scale_choice_arbitrary</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">scale_choice_arbitrary</span>
<span class="n">nnlo_splitting_exact</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">nnlo_splitting_exact</span>
<span class="n">nnlo_splitting_param</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">nnlo_splitting_param</span>
<span class="n">nnlo_splitting_Nfitav</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">nnlo_splitting_Nfitav</span>
<span class="n">nnlo_splitting_Nfiterr1</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">nnlo_splitting_Nfiterr1</span>
<span class="n">nnlo_splitting_Nfiterr2</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">nnlo_splitting_Nfiterr2</span>
<span class="n">n3lo_splitting_exact</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_splitting_exact</span>
<span class="n">n3lo_splitting_param</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_splitting_param</span>
<span class="n">n3lo_splitting_Nfitav</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_splitting_Nfitav</span>
<span class="n">n3lo_splitting_Nfiterr1</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_splitting_Nfiterr1</span>
<span class="n">n3lo_splitting_Nfiterr2</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_splitting_Nfiterr2</span>
<span class="n">n3lo_splitting_approximation_up_to_2310_05744</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_splitting_approximation_up_to_2310_05744</span>
<span class="n">n3lo_splitting_approximation_up_to_2404_09701</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_splitting_approximation_up_to_2404_09701</span>
<span class="n">n3lo_splitting_approximation_up_to_2410_08089</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_splitting_approximation_up_to_2410_08089</span>
<span class="n">n3lo_splitting_approximation_up_to_2310</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_splitting_approximation_up_to_2310</span>
<span class="n">n3lo_splitting_approximation_up_to_2404</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_splitting_approximation_up_to_2404</span>
<span class="n">n3lo_splitting_approximation_up_to_2410</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_splitting_approximation_up_to_2410</span>
<span class="n">n3lo_splitting_approximation_up_to_2512</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_splitting_approximation_up_to_2512</span>
<span class="n">nnlo_nfthreshold_exact</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">nnlo_nfthreshold_exact</span>
<span class="n">nnlo_nfthreshold_param</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">nnlo_nfthreshold_param</span>
<span class="n">n3lo_nfthreshold_libOME_2512</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_nfthreshold_libOME_2512</span>
<span class="n">n3lo_nfthreshold_libOME_2510</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_nfthreshold_libOME_2510</span>
<span class="n">n3lo_nfthreshold_exact_fortran</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_nfthreshold_exact_fortran</span>
<span class="n">n3lo_nfthreshold_off</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_nfthreshold_off</span>
<span class="n">n3lo_nfthreshold_on</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_nfthreshold_on</span>
<span class="n">n3lo_nfthreshold_libOME</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">n3lo_nfthreshold_libOME</span>
<span class="n">factscheme_MSbar</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">factscheme_MSbar</span>
<span class="n">factscheme_DIS</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">factscheme_DIS</span>
<span class="n">factscheme_PolMSbar</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">factscheme_PolMSbar</span>
<span class="n">factscheme_FragMSbar</span> <span class="o">=</span> <span class="n">cvar</span><span class="o">.</span><span class="n">factscheme_FragMSbar</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Alexander Karlberg, Paolo Nason, Gavin Salam, Giulia Zanderighi, Frederic Dreyer, Juan Rojo.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>